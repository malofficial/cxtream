<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>cxtream: Tuple and variadic template utilites.</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="styles.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">cxtream
   &#160;<span id="projectnumber">0.5.1</span>
   </div>
   <div id="projectbrief">C++17 data pipeline with Python bindings.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Tuple and variadic template utilites.</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcxtream_1_1utility_1_1variadic__find.html">cxtream::utility::variadic_find&lt; T1, T2, Ts &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the first index of a type in a variadic template list.  <a href="structcxtream_1_1utility_1_1variadic__find.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcxtream_1_1utility_1_1maybe__tuple__impl.html">cxtream::utility::maybe_tuple_impl&lt; N, Ts &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap variadic template pack in a tuple if there is more than one type.  <a href="structcxtream_1_1utility_1_1maybe__tuple__impl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcxtream_1_1utility_1_1tuple__contains.html">cxtream::utility::tuple_contains&lt; T, Tuple &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check whether a tuple contains a given type.  <a href="structcxtream_1_1utility_1_1tuple__contains.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ga08fe58537405efca38e12378b1e1b3b5"><td class="memTemplParams" colspan="2">template&lt;std::size_t Offset, std::size_t N&gt; </td></tr>
<tr class="memitem:ga08fe58537405efca38e12378b1e1b3b5"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tuple.html#ga08fe58537405efca38e12378b1e1b3b5">cxtream::utility::make_offset_index_sequence</a> = decltype(plus&lt; Offset &gt;(std::make_index_sequence&lt; N &gt;{}))</td></tr>
<tr class="memdesc:ga08fe58537405efca38e12378b1e1b3b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make std::index_sequence with the given offset.  <a href="group___tuple.html#ga08fe58537405efca38e12378b1e1b3b5">More...</a><br /></td></tr>
<tr class="separator:ga08fe58537405efca38e12378b1e1b3b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:gadb7dcce9bcb4042079f46554342ddffe"><td class="memTemplParams" colspan="2">template&lt;std::size_t Value, std::size_t... Is&gt; </td></tr>
<tr class="memitem:gadb7dcce9bcb4042079f46554342ddffe"><td class="memTemplItemLeft" align="right" valign="top">constexpr std::index_sequence&lt;(Value+Is)... &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tuple.html#gadb7dcce9bcb4042079f46554342ddffe">cxtream::utility::plus</a> (std::index_sequence&lt; Is... &gt;)</td></tr>
<tr class="memdesc:gadb7dcce9bcb4042079f46554342ddffe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a number to all values in std::index_sequence.  <a href="group___tuple.html#gadb7dcce9bcb4042079f46554342ddffe">More...</a><br /></td></tr>
<tr class="separator:gadb7dcce9bcb4042079f46554342ddffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga931ec6c73cd4e5348d08e78b7a1231d7"><td class="memTemplParams" colspan="2">template&lt;typename Tuple , typename Fun &gt; </td></tr>
<tr class="memitem:ga931ec6c73cd4e5348d08e78b7a1231d7"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tuple.html#ga931ec6c73cd4e5348d08e78b7a1231d7">cxtream::utility::tuple_for_each</a> (Tuple &amp;&amp;tuple, Fun &amp;&amp;fun)</td></tr>
<tr class="memdesc:ga931ec6c73cd4e5348d08e78b7a1231d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a function on each element of a tuple.  <a href="group___tuple.html#ga931ec6c73cd4e5348d08e78b7a1231d7">More...</a><br /></td></tr>
<tr class="separator:ga931ec6c73cd4e5348d08e78b7a1231d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac26bcd44a723f14d966b7ea151a44845"><td class="memTemplParams" colspan="2">template&lt;typename Tuple , typename Fun &gt; </td></tr>
<tr class="memitem:gac26bcd44a723f14d966b7ea151a44845"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tuple.html#gac26bcd44a723f14d966b7ea151a44845">cxtream::utility::tuple_transform</a> (Tuple &amp;&amp;tuple, Fun &amp;&amp;fun)</td></tr>
<tr class="memdesc:gac26bcd44a723f14d966b7ea151a44845"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform each element of a tuple.  <a href="group___tuple.html#gac26bcd44a723f14d966b7ea151a44845">More...</a><br /></td></tr>
<tr class="separator:gac26bcd44a723f14d966b7ea151a44845"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae9a2159093e5f07cb870b760f759a037"><td class="memTemplParams" colspan="2">template&lt;typename... Types, typename Tuple &gt; </td></tr>
<tr class="memitem:gae9a2159093e5f07cb870b760f759a037"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tuple.html#gae9a2159093e5f07cb870b760f759a037">cxtream::utility::tuple_type_view</a> (Tuple &amp;tuple)</td></tr>
<tr class="memdesc:gae9a2159093e5f07cb870b760f759a037"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a sub-tuple made of references to the original tuple (selected by type).  <a href="group___tuple.html#gae9a2159093e5f07cb870b760f759a037">More...</a><br /></td></tr>
<tr class="separator:gae9a2159093e5f07cb870b760f759a037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1d93b06bed7c788cbd2d85e6531c743c"><td class="memTemplParams" colspan="2">template&lt;std::size_t... Idxs, typename Tuple &gt; </td></tr>
<tr class="memitem:ga1d93b06bed7c788cbd2d85e6531c743c"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tuple.html#ga1d93b06bed7c788cbd2d85e6531c743c">cxtream::utility::tuple_index_view</a> (Tuple &amp;tuple, std::index_sequence&lt; Idxs... &gt;={})</td></tr>
<tr class="memdesc:ga1d93b06bed7c788cbd2d85e6531c743c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Makes a sub-tuple made of references to the original tuple (selected by index).  <a href="group___tuple.html#ga1d93b06bed7c788cbd2d85e6531c743c">More...</a><br /></td></tr>
<tr class="separator:ga1d93b06bed7c788cbd2d85e6531c743c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7a1ce66b911810f971d00944f9814257"><td class="memTemplParams" colspan="2">template&lt;typename... Tuples&gt; </td></tr>
<tr class="memitem:ga7a1ce66b911810f971d00944f9814257"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tuple.html#ga7a1ce66b911810f971d00944f9814257">cxtream::utility::tuple_cat_unique</a> (Tuples &amp;&amp;... tuples)</td></tr>
<tr class="memdesc:ga7a1ce66b911810f971d00944f9814257"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate two tuples and keep only the first element of each type.  <a href="group___tuple.html#ga7a1ce66b911810f971d00944f9814257">More...</a><br /></td></tr>
<tr class="separator:ga7a1ce66b911810f971d00944f9814257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade9aa359d14e97bc3ab7b983ac0a863e"><td class="memTemplParams" colspan="2"><a id="gade9aa359d14e97bc3ab7b983ac0a863e"></a>
template&lt;typename Tuple , size_t... Is&gt; </td></tr>
<tr class="memitem:gade9aa359d14e97bc3ab7b983ac0a863e"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tuple.html#gade9aa359d14e97bc3ab7b983ac0a863e">cxtream::utility::tuple_print</a> (std::ostream &amp;out, const Tuple &amp;tuple, std::index_sequence&lt; Is... &gt;)</td></tr>
<tr class="memdesc:gade9aa359d14e97bc3ab7b983ac0a863e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tuple pretty printing to std::ostream. <br /></td></tr>
<tr class="separator:gade9aa359d14e97bc3ab7b983ac0a863e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga98934a7282bbdc5832a217b583934b11"><td class="memTemplParams" colspan="2"><a id="ga98934a7282bbdc5832a217b583934b11"></a>
template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:ga98934a7282bbdc5832a217b583934b11"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tuple.html#ga98934a7282bbdc5832a217b583934b11">cxtream::utility::operator&lt;&lt;</a> (std::ostream &amp;out, const std::tuple&lt; Ts... &gt; &amp;tuple)</td></tr>
<tr class="memdesc:ga98934a7282bbdc5832a217b583934b11"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tuple pretty printing to std::ostream. <br /></td></tr>
<tr class="separator:ga98934a7282bbdc5832a217b583934b11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7753bf6662610016f7e95f17c9679a43"><td class="memTemplParams" colspan="2">template&lt;typename... Rem, typename Tuple &gt; </td></tr>
<tr class="memitem:ga7753bf6662610016f7e95f17c9679a43"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tuple.html#ga7753bf6662610016f7e95f17c9679a43">cxtream::utility::tuple_remove</a> (Tuple tuple)</td></tr>
<tr class="memdesc:ga7753bf6662610016f7e95f17c9679a43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove types from a tuple.  <a href="group___tuple.html#ga7753bf6662610016f7e95f17c9679a43">More...</a><br /></td></tr>
<tr class="separator:ga7753bf6662610016f7e95f17c9679a43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga69220034add9588a5d5c3e9a4ee0569a"><td class="memTemplParams" colspan="2">template&lt;typename Rng , CONCEPT_REQUIRES_(ranges::Range&lt; Rng &gt;() &amp;&amp;!ranges::View&lt; Rng &gt;()) &gt; </td></tr>
<tr class="memitem:ga69220034add9588a5d5c3e9a4ee0569a"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tuple.html#ga69220034add9588a5d5c3e9a4ee0569a">cxtream::utility::unzip</a> (Rng range_of_tuples)</td></tr>
<tr class="memdesc:ga69220034add9588a5d5c3e9a4ee0569a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unzips a range of tuples to a tuple of ranges.  <a href="group___tuple.html#ga69220034add9588a5d5c3e9a4ee0569a">More...</a><br /></td></tr>
<tr class="separator:ga69220034add9588a5d5c3e9a4ee0569a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2b00ecb5b3207ca80374d74824b6c76d"><td class="memTemplParams" colspan="2">template&lt;bool Enable, typename RangeT &gt; </td></tr>
<tr class="memitem:ga2b00ecb5b3207ca80374d74824b6c76d"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tuple.html#ga2b00ecb5b3207ca80374d74824b6c76d">cxtream::utility::unzip_if</a> (RangeT &amp;&amp;range)</td></tr>
<tr class="memdesc:ga2b00ecb5b3207ca80374d74824b6c76d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unzips a range of tuples to a tuple of ranges if a constexpr condition holds.  <a href="group___tuple.html#ga2b00ecb5b3207ca80374d74824b6c76d">More...</a><br /></td></tr>
<tr class="separator:ga2b00ecb5b3207ca80374d74824b6c76d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga413c130df275aee08c3f352b5a0f54e1"><td class="memTemplParams" colspan="2">template&lt;typename Tuple &gt; </td></tr>
<tr class="memitem:ga413c130df275aee08c3f352b5a0f54e1"><td class="memTemplItemLeft" align="right" valign="top">decltype(auto)&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tuple.html#ga413c130df275aee08c3f352b5a0f54e1">cxtream::utility::maybe_untuple</a> (Tuple &amp;&amp;tuple)</td></tr>
<tr class="memdesc:ga413c130df275aee08c3f352b5a0f54e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract a value from a tuple if the tuple contains only a single value.  <a href="group___tuple.html#ga413c130df275aee08c3f352b5a0f54e1">More...</a><br /></td></tr>
<tr class="separator:ga413c130df275aee08c3f352b5a0f54e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0a1d260a05add0e6d8f95a46afd640ce"><td class="memTemplParams" colspan="2">template&lt;std::size_t N, typename RARng &gt; </td></tr>
<tr class="memitem:ga0a1d260a05add0e6d8f95a46afd640ce"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tuple.html#ga0a1d260a05add0e6d8f95a46afd640ce">cxtream::utility::range_to_tuple</a> (RARng &amp;&amp;rng)</td></tr>
<tr class="memdesc:ga0a1d260a05add0e6d8f95a46afd640ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a range to a tuple.  <a href="group___tuple.html#ga0a1d260a05add0e6d8f95a46afd640ce">More...</a><br /></td></tr>
<tr class="separator:ga0a1d260a05add0e6d8f95a46afd640ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8a2c66831b08f69b82c85a1c19ef87c4"><td class="memTemplParams" colspan="2">template&lt;std::size_t N, typename Fun &gt; </td></tr>
<tr class="memitem:ga8a2c66831b08f69b82c85a1c19ef87c4"><td class="memTemplItemLeft" align="right" valign="top">constexpr Fun&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tuple.html#ga8a2c66831b08f69b82c85a1c19ef87c4">cxtream::utility::times_with_index</a> (Fun &amp;&amp;fun)</td></tr>
<tr class="memdesc:ga8a2c66831b08f69b82c85a1c19ef87c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Repeat a function N times in compile time.  <a href="group___tuple.html#ga8a2c66831b08f69b82c85a1c19ef87c4">More...</a><br /></td></tr>
<tr class="separator:ga8a2c66831b08f69b82c85a1c19ef87c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga38640c5ed120d6108645cb9a96282c05"><td class="memTemplParams" colspan="2">template&lt;typename Tuple , typename Fun &gt; </td></tr>
<tr class="memitem:ga38640c5ed120d6108645cb9a96282c05"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tuple.html#ga38640c5ed120d6108645cb9a96282c05">cxtream::utility::tuple_for_each_with_index</a> (Tuple &amp;&amp;tuple, Fun &amp;&amp;fun)</td></tr>
<tr class="memdesc:ga38640c5ed120d6108645cb9a96282c05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="group___tuple.html#ga931ec6c73cd4e5348d08e78b7a1231d7" title="Apply a function on each element of a tuple. ">tuple_for_each()</a>, but with index available.  <a href="group___tuple.html#ga38640c5ed120d6108645cb9a96282c05">More...</a><br /></td></tr>
<tr class="separator:ga38640c5ed120d6108645cb9a96282c05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae1bf44f2ad53595b089d1dec0947f682"><td class="memTemplParams" colspan="2">template&lt;typename Tuple , typename Fun &gt; </td></tr>
<tr class="memitem:gae1bf44f2ad53595b089d1dec0947f682"><td class="memTemplItemLeft" align="right" valign="top">constexpr auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group___tuple.html#gae1bf44f2ad53595b089d1dec0947f682">cxtream::utility::tuple_transform_with_index</a> (Tuple &amp;&amp;tuple, Fun &amp;&amp;fun)</td></tr>
<tr class="memdesc:gae1bf44f2ad53595b089d1dec0947f682"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <a class="el" href="group___tuple.html#gac26bcd44a723f14d966b7ea151a44845" title="Transform each element of a tuple. ">tuple_transform()</a>, but with index available.  <a href="group___tuple.html#gae1bf44f2ad53595b089d1dec0947f682">More...</a><br /></td></tr>
<tr class="separator:gae1bf44f2ad53595b089d1dec0947f682"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="ga08fe58537405efca38e12378b1e1b3b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga08fe58537405efca38e12378b1e1b3b5">&#9670;&nbsp;</a></span>make_offset_index_sequence</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Offset, std::size_t N&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="group___tuple.html#ga08fe58537405efca38e12378b1e1b3b5">cxtream::utility::make_offset_index_sequence</a> = typedef decltype(plus&lt;Offset&gt;(std::make_index_sequence&lt;N&gt;{}))</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make std::index_sequence with the given offset. </p>
<p>Example: </p><div class="fragment"><div class="line">std::is_same&lt;decltype(make_offset_index_sequence&lt;3, 4&gt;()),</div><div class="line">                      std::index_sequence&lt;3, 4, 5, 6&gt;&gt;;</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="tuple_8hpp_source.html#l00092">92</a> of file <a class="el" href="tuple_8hpp_source.html">tuple.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ga413c130df275aee08c3f352b5a0f54e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga413c130df275aee08c3f352b5a0f54e1">&#9670;&nbsp;</a></span>maybe_untuple()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tuple &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) cxtream::utility::maybe_untuple </td>
          <td>(</td>
          <td class="paramtype">Tuple &amp;&amp;&#160;</td>
          <td class="paramname"><em>tuple</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract a value from a tuple if the tuple contains only a single value. </p>
<p>If the tuple contains zero or more than one element, this is an identity.</p>
<p>Example: </p><div class="fragment"><div class="line">std::tuple&lt;int, double&gt; t1{1, 3.};</div><div class="line"><span class="keyword">auto</span> t2 = <a class="code" href="group___tuple.html#ga413c130df275aee08c3f352b5a0f54e1">maybe_untuple</a>(t1);</div><div class="line">static_assert(std::is_same_v&lt;decltype(t2), std::tuple&lt;int, double&gt;&gt;);</div><div class="line"></div><div class="line">std::tuple&lt;int&gt; t3{1};</div><div class="line"><span class="keyword">auto</span> t4 = <a class="code" href="group___tuple.html#ga413c130df275aee08c3f352b5a0f54e1">maybe_untuple</a>(t3);</div><div class="line">static_assert(std::is_same_v&lt;decltype(t4), <span class="keywordtype">int</span>&gt;);</div><div class="line"></div><div class="line"><span class="keywordtype">int</span> i = 1;</div><div class="line">std::tuple&lt;int&amp;&gt; t5{i};</div><div class="line"><span class="keyword">auto</span>&amp; t6 = <a class="code" href="group___tuple.html#ga413c130df275aee08c3f352b5a0f54e1">maybe_untuple</a>(t5);</div><div class="line">static_assert(std::is_same_v&lt;decltype(t6), <span class="keywordtype">int</span>&amp;&gt;);</div><div class="line">t6 = 2;</div><div class="line">BOOST_TEST(i == 2);</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="tuple_8hpp_source.html#l00522">522</a> of file <a class="el" href="tuple_8hpp_source.html">tuple.hpp</a>.</p>

</div>
</div>
<a id="gadb7dcce9bcb4042079f46554342ddffe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gadb7dcce9bcb4042079f46554342ddffe">&#9670;&nbsp;</a></span>plus()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t Value, std::size_t... Is&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr std::index_sequence&lt;(Value + Is)...&gt; cxtream::utility::plus </td>
          <td>(</td>
          <td class="paramtype">std::index_sequence&lt; Is... &gt;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a number to all values in std::index_sequence. </p>
<p>Example: </p><div class="fragment"><div class="line">std::is_same&lt;decltype(plus&lt;2&gt;(std::index_sequence&lt;1, 3, 4&gt;{})),</div><div class="line">                              std::index_sequence&lt;3, 5, 6&gt;&gt;;</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="tuple_8hpp_source.html#l00078">78</a> of file <a class="el" href="tuple_8hpp_source.html">tuple.hpp</a>.</p>

</div>
</div>
<a id="ga0a1d260a05add0e6d8f95a46afd640ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga0a1d260a05add0e6d8f95a46afd640ce">&#9670;&nbsp;</a></span>range_to_tuple()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N, typename RARng &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto cxtream::utility::range_to_tuple </td>
          <td>(</td>
          <td class="paramtype">RARng &amp;&amp;&#160;</td>
          <td class="paramname"><em>rng</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a range to a tuple. </p>
<p>Example: </p><div class="fragment"><div class="line">std::vector&lt;std::unique_ptr&lt;int&gt;&gt; data;</div><div class="line">data.emplace_back(std::make_unique&lt;int&gt;(5));</div><div class="line">data.emplace_back(std::make_unique&lt;int&gt;(6));</div><div class="line">data.emplace_back(std::make_unique&lt;int&gt;(7));</div><div class="line"></div><div class="line"><span class="keyword">auto</span> tpl = range_to_tuple&lt;3&gt;(std::move(data));</div><div class="line">assert(tpl == std::make_tuple(5, 6, 7));</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="tuple_8hpp_source.html#l00554">554</a> of file <a class="el" href="tuple_8hpp_source.html">tuple.hpp</a>.</p>

</div>
</div>
<a id="ga8a2c66831b08f69b82c85a1c19ef87c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga8a2c66831b08f69b82c85a1c19ef87c4">&#9670;&nbsp;</a></span>times_with_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N, typename Fun &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr Fun cxtream::utility::times_with_index </td>
          <td>(</td>
          <td class="paramtype">Fun &amp;&amp;&#160;</td>
          <td class="paramname"><em>fun</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Repeat a function N times in compile time. </p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> tpl = std::make_tuple(1, 0.25, <span class="charliteral">&#39;a&#39;</span>);</div><div class="line"></div><div class="line">times_with_index&lt;3&gt;([&amp;tpl](<span class="keyword">auto</span> index) {</div><div class="line">    ++std::get&lt;index&gt;(tpl);</div><div class="line">});</div><div class="line">assert(tpl == std::make_tuple(2, 1.25, <span class="charliteral">&#39;b&#39;</span>));</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="tuple_8hpp_source.html#l00586">586</a> of file <a class="el" href="tuple_8hpp_source.html">tuple.hpp</a>.</p>

</div>
</div>
<a id="ga7a1ce66b911810f971d00944f9814257"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7a1ce66b911810f971d00944f9814257">&#9670;&nbsp;</a></span>tuple_cat_unique()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Tuples&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto cxtream::utility::tuple_cat_unique </td>
          <td>(</td>
          <td class="paramtype">Tuples &amp;&amp;...&#160;</td>
          <td class="paramname"><em>tuples</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenate two tuples and keep only the first element of each type. </p>
<p>Note: All the reference types are decayed during this operation.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> t1 = std::make_tuple(0, <span class="charliteral">&#39;1&#39;</span>);</div><div class="line"><span class="keyword">auto</span> t2 = std::make_tuple(2, <span class="charliteral">&#39;3&#39;</span>, 5.);</div><div class="line"><span class="keyword">auto</span> t3 = <a class="code" href="group___tuple.html#ga7a1ce66b911810f971d00944f9814257">tuple_cat_unique</a>(t1, t2);</div><div class="line">static_assert(std::is_same&lt;std::tuple&lt;int, char, double&gt;, decltype(t3)&gt;{});</div><div class="line">assert(t2 == std::make_tuple(0, <span class="charliteral">&#39;1&#39;</span>, 5.));</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="tuple_8hpp_source.html#l00291">291</a> of file <a class="el" href="tuple_8hpp_source.html">tuple.hpp</a>.</p>

</div>
</div>
<a id="ga931ec6c73cd4e5348d08e78b7a1231d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga931ec6c73cd4e5348d08e78b7a1231d7">&#9670;&nbsp;</a></span>tuple_for_each()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tuple , typename Fun &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto cxtream::utility::tuple_for_each </td>
          <td>(</td>
          <td class="paramtype">Tuple &amp;&amp;&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fun &amp;&amp;&#160;</td>
          <td class="paramname"><em>fun</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply a function on each element of a tuple. </p>
<p>The order of application is from the first to the last element.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> tpl = std::make_tuple(5, 2.);</div><div class="line"><a class="code" href="group___tuple.html#ga931ec6c73cd4e5348d08e78b7a1231d7">tuple_for_each</a>(tpl, [](<span class="keyword">auto</span>&amp; val) { std::cout &lt;&lt; val &lt;&lt; <span class="charliteral">&#39;\n&#39;</span>; });</div></div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>The function after application. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tuple_8hpp_source.html#l00120">120</a> of file <a class="el" href="tuple_8hpp_source.html">tuple.hpp</a>.</p>

</div>
</div>
<a id="ga38640c5ed120d6108645cb9a96282c05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga38640c5ed120d6108645cb9a96282c05">&#9670;&nbsp;</a></span>tuple_for_each_with_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tuple , typename Fun &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto cxtream::utility::tuple_for_each_with_index </td>
          <td>(</td>
          <td class="paramtype">Tuple &amp;&amp;&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fun &amp;&amp;&#160;</td>
          <td class="paramname"><em>fun</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to <a class="el" href="group___tuple.html#ga931ec6c73cd4e5348d08e78b7a1231d7" title="Apply a function on each element of a tuple. ">tuple_for_each()</a>, but with index available. </p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> tpl = std::make_tuple(1, 2.);</div><div class="line"></div><div class="line"><a class="code" href="group___tuple.html#ga38640c5ed120d6108645cb9a96282c05">tuple_for_each_with_index</a>(tpl, [](<span class="keyword">auto</span>&amp; val, <span class="keyword">auto</span> index) {</div><div class="line">    val += index;</div><div class="line">});</div><div class="line"></div><div class="line">assert(tpl == std::make_tuple(1, 3.));</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="tuple_8hpp_source.html#l00605">605</a> of file <a class="el" href="tuple_8hpp_source.html">tuple.hpp</a>.</p>

</div>
</div>
<a id="ga1d93b06bed7c788cbd2d85e6531c743c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga1d93b06bed7c788cbd2d85e6531c743c">&#9670;&nbsp;</a></span>tuple_index_view()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t... Idxs, typename Tuple &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto cxtream::utility::tuple_index_view </td>
          <td>(</td>
          <td class="paramtype">Tuple &amp;&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::index_sequence&lt; Idxs... &gt;&#160;</td>
          <td class="paramname"> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a sub-tuple made of references to the original tuple (selected by index). </p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> tpl = std::make_tuple(0, 5., <span class="charliteral">&#39;c&#39;</span>);</div><div class="line"><span class="keyword">auto</span> subtpl = tuple_index_view&lt;2, 0&gt;(t1);</div><div class="line"><span class="comment">// or equivalently: auto subtpl = tuple_index_view(t1, std::index_sequence&lt;2, 0&gt;{});</span></div><div class="line">static_assert(std::is_same&lt;std::tuple&lt;char&amp;, int&amp;&gt;, decltype(subtpl)&gt;{});</div><div class="line">assert(subtpl == std::tuple&lt;char, int&gt;{<span class="charliteral">&#39;c&#39;</span>, 0});</div></div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>The view of the original tuple. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tuple_8hpp_source.html#l00205">205</a> of file <a class="el" href="tuple_8hpp_source.html">tuple.hpp</a>.</p>

</div>
</div>
<a id="ga7753bf6662610016f7e95f17c9679a43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga7753bf6662610016f7e95f17c9679a43">&#9670;&nbsp;</a></span>tuple_remove()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Rem, typename Tuple &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto cxtream::utility::tuple_remove </td>
          <td>(</td>
          <td class="paramtype">Tuple&#160;</td>
          <td class="paramname"><em>tuple</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove types from a tuple. </p>
<p>Note: All the reference types are decayed during this operation.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> t1 = std::make_tuple(0, <span class="charliteral">&#39;1&#39;</span>);</div><div class="line"><span class="keyword">auto</span> t2 = tuple_remove&lt;int&gt;(t1);</div><div class="line">static_assert(std::is_same&lt;std::tuple&lt;char&gt;, decltype(t2)&gt;{});</div><div class="line">assert(t2 == std::make_tuple(<span class="charliteral">&#39;1&#39;</span>));</div><div class="line"><span class="keyword">auto</span> t3 = tuple_remove&lt;int, char&gt;(std::make_tuple(0, <span class="charliteral">&#39;a&#39;</span>, 3L, <span class="charliteral">&#39;b&#39;</span>));</div><div class="line">static_assert(std::is_same&lt;std::tuple&lt;long&gt;, decltype(t3)&gt;{});</div><div class="line">assert(t3 == std::make_tuple(3L));</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="tuple_8hpp_source.html#l00334">334</a> of file <a class="el" href="tuple_8hpp_source.html">tuple.hpp</a>.</p>

</div>
</div>
<a id="gac26bcd44a723f14d966b7ea151a44845"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gac26bcd44a723f14d966b7ea151a44845">&#9670;&nbsp;</a></span>tuple_transform()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tuple , typename Fun &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto cxtream::utility::tuple_transform </td>
          <td>(</td>
          <td class="paramtype">Tuple &amp;&amp;&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fun &amp;&amp;&#160;</td>
          <td class="paramname"><em>fun</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform each element of a tuple. </p>
<p>The order of application is unspecified.</p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> t1 = std::make_tuple(0, 10L, 5.);</div><div class="line"><span class="keyword">auto</span> t2 = <a class="code" href="group___tuple.html#gac26bcd44a723f14d966b7ea151a44845">tuple_transform</a>(t1, [](<span class="keyword">const</span> <span class="keyword">auto</span> &amp;v) { <span class="keywordflow">return</span> v + 1; });</div><div class="line">static_assert(std::is_same&lt;std::tuple&lt;int, long, double&gt;, decltype(t2)&gt;{});</div><div class="line">assert(t2 == std::make_tuple(0 + 1, 10L + 1, 5. + 1));</div></div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>The transformed tuple. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tuple_8hpp_source.html#l00155">155</a> of file <a class="el" href="tuple_8hpp_source.html">tuple.hpp</a>.</p>

</div>
</div>
<a id="gae1bf44f2ad53595b089d1dec0947f682"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae1bf44f2ad53595b089d1dec0947f682">&#9670;&nbsp;</a></span>tuple_transform_with_index()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Tuple , typename Fun &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto cxtream::utility::tuple_transform_with_index </td>
          <td>(</td>
          <td class="paramtype">Tuple &amp;&amp;&#160;</td>
          <td class="paramname"><em>tuple</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Fun &amp;&amp;&#160;</td>
          <td class="paramname"><em>fun</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to <a class="el" href="group___tuple.html#gac26bcd44a723f14d966b7ea151a44845" title="Transform each element of a tuple. ">tuple_transform()</a>, but with index available. </p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> tpl = std::make_tuple(1, 0.25, <span class="charliteral">&#39;a&#39;</span>);</div><div class="line"></div><div class="line"><span class="keyword">auto</span> tpl2 = <a class="code" href="group___tuple.html#gae1bf44f2ad53595b089d1dec0947f682">tuple_transform_with_index</a>(tpl, [](<span class="keyword">auto</span>&amp;&amp; elem, <span class="keyword">auto</span> index) {</div><div class="line">    <span class="keywordflow">return</span> elem + index;</div><div class="line">});</div><div class="line"></div><div class="line">assert(tpl2 == std::make_tuple(1, 1.25, <span class="charliteral">&#39;c&#39;</span>));</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="tuple_8hpp_source.html#l00641">641</a> of file <a class="el" href="tuple_8hpp_source.html">tuple.hpp</a>.</p>

</div>
</div>
<a id="gae9a2159093e5f07cb870b760f759a037"></a>
<h2 class="memtitle"><span class="permalink"><a href="#gae9a2159093e5f07cb870b760f759a037">&#9670;&nbsp;</a></span>tuple_type_view()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Types, typename Tuple &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">constexpr auto cxtream::utility::tuple_type_view </td>
          <td>(</td>
          <td class="paramtype">Tuple &amp;&#160;</td>
          <td class="paramname"><em>tuple</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Makes a sub-tuple made of references to the original tuple (selected by type). </p>
<p>Example: </p><div class="fragment"><div class="line"><span class="keyword">auto</span> tpl = std::make_tuple(0, 5., <span class="charliteral">&#39;c&#39;</span>);</div><div class="line"><span class="keyword">auto</span> subtpl = tuple_type_view&lt;char, int&gt;(t1);</div><div class="line">static_assert(std::is_same&lt;std::tuple&lt;char&amp;, int&amp;&gt;, decltype(subtpl)&gt;{});</div><div class="line">assert(subtpl == std::tuple&lt;char, int&gt;{<span class="charliteral">&#39;c&#39;</span>, 0});</div></div><!-- fragment --><dl class="section return"><dt>Returns</dt><dd>The view of the original tuple. </dd></dl>

<p class="definition">Definition at line <a class="el" href="tuple_8hpp_source.html#l00186">186</a> of file <a class="el" href="tuple_8hpp_source.html">tuple.hpp</a>.</p>

</div>
</div>
<a id="ga69220034add9588a5d5c3e9a4ee0569a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga69220034add9588a5d5c3e9a4ee0569a">&#9670;&nbsp;</a></span>unzip()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Rng , CONCEPT_REQUIRES_(ranges::Range&lt; Rng &gt;() &amp;&amp;!ranges::View&lt; Rng &gt;()) &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto cxtream::utility::unzip </td>
          <td>(</td>
          <td class="paramtype">Rng&#160;</td>
          <td class="paramname"><em>range_of_tuples</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unzips a range of tuples to a tuple of ranges. </p>
<p>Specialization of unzip function for views.</p>
<p>Example: </p><div class="fragment"><div class="line">std::vector&lt;std::tuple&lt;int, double&gt;&gt; data{};</div><div class="line">data.emplace_back(1, 5.);</div><div class="line">data.emplace_back(2, 6.);</div><div class="line">data.emplace_back(3, 7.);</div><div class="line"></div><div class="line">std::vector&lt;int&gt; va;</div><div class="line">std::vector&lt;double&gt; vb;</div><div class="line">std::tie(va, vb) = <a class="code" href="group___tuple.html#ga69220034add9588a5d5c3e9a4ee0569a">unzip</a>(data);</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="tuple_8hpp_source.html#l00408">408</a> of file <a class="el" href="tuple_8hpp_source.html">tuple.hpp</a>.</p>

</div>
</div>
<a id="ga2b00ecb5b3207ca80374d74824b6c76d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ga2b00ecb5b3207ca80374d74824b6c76d">&#9670;&nbsp;</a></span>unzip_if()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;bool Enable, typename RangeT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">decltype(auto) cxtream::utility::unzip_if </td>
          <td>(</td>
          <td class="paramtype">RangeT &amp;&amp;&#160;</td>
          <td class="paramname"><em>range</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unzips a range of tuples to a tuple of ranges if a constexpr condition holds. </p>
<p>This method is enabled or disabled by its first template parameter. If disabled, it returns identity. If enabled, it returns the same thing as <a class="el" href="group___tuple.html#ga69220034add9588a5d5c3e9a4ee0569a" title="Unzips a range of tuples to a tuple of ranges. ">unzip()</a> would return.</p>
<p>Example: </p><div class="fragment"><div class="line">std::vector&lt;std::tuple&lt;int, double&gt;&gt; data{};</div><div class="line">data.emplace_back(1, 5.);</div><div class="line">data.emplace_back(2, 6.);</div><div class="line">data.emplace_back(3, 7.);</div><div class="line"></div><div class="line">std::vector&lt;int&gt; va;</div><div class="line">std::vector&lt;double&gt; vb;</div><div class="line">std::tie(va, vb) = unzip_if&lt;true&gt;(data);</div><div class="line"></div><div class="line">std::vector&lt;int&gt; vc = unzip_if&lt;false&gt;(va);</div></div><!-- fragment --> 
<p class="definition">Definition at line <a class="el" href="tuple_8hpp_source.html#l00468">468</a> of file <a class="el" href="tuple_8hpp_source.html">tuple.hpp</a>.</p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
